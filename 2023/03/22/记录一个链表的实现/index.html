<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>记录一个链表的实现 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="前言时隔半年多没有敲代码了，既然已经在iPad上安装好了iVim，接下来就又可以敲代码了，所以就打算先搓一个最基本的数据结构——链表。 虽然很早以前就看过数据结构，但是一个真正的完整的自己用的链表我还是第一次写，以前的都是在写算法题时需要写的半成品，而且封装非常丑陋，甚至不封装，毕竟是一次性的代码，只要运行通过了就不会再看了。所以这次要写的，是一个完整的封装好看的链表。  准备工作在正式开始写代码">
<meta property="og:type" content="article">
<meta property="og:title" content="记录一个链表的实现">
<meta property="og:url" content="http://example.com/2023/03/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言时隔半年多没有敲代码了，既然已经在iPad上安装好了iVim，接下来就又可以敲代码了，所以就打算先搓一个最基本的数据结构——链表。 虽然很早以前就看过数据结构，但是一个真正的完整的自己用的链表我还是第一次写，以前的都是在写算法题时需要写的半成品，而且封装非常丑陋，甚至不封装，毕竟是一次性的代码，只要运行通过了就不会再看了。所以这次要写的，是一个完整的封装好看的链表。  准备工作在正式开始写代码">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-03-22T14:23:18.000Z">
<meta property="article:modified_time" content="2023-03-22T14:48:27.359Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-记录一个链表的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2023-03-22T14:23:18.000Z" itemprop="datePublished">2023-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      记录一个链表的实现
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时隔半年多没有敲代码了，既然已经在iPad上安装好了iVim，接下来就又可以敲代码了，所以就打算先搓一个最基本的数据结构——链表。</p>
<p>虽然很早以前就看过数据结构，但是一个真正的完整的自己用的链表我还是第一次写，以前的都是在写算法题时需要写的半成品，而且封装非常丑陋，甚至不封装，毕竟是一次性的代码，只要运行通过了就不会再看了。所以这次要写的，是一个完整的封装好看的链表。</p>
<hr>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在正式开始写代码之前还需要一些准备工作，虽然链表是个很简单的数据结构，但是在一些地方的实现上会有所不同，首先需要明确自己要写的是一个什么样的链表。我的想法是，既然不是写算法题，而是自用，那就不用死扣性能，而是要让一个链表包含尽可能多的功能，而且有可复用性，所以列出了以下几点：</p>
<ol>
<li>带有头节点，头节点用于保存链表的属性，例如长度。</li>
<li>具有前继和后继，能够双向遍历，既双向链表。</li>
<li>头节点的前继指向链表的尾节点，尾节点的后继指向头节点，既循环链表。</li>
<li>保存的数据类型用void*，用memcpy赋值，这个是看大佬的代码学到的，如果是以前我应该会直接使用传入的数据的指针。</li>
</ol>
<p>所以综上所述，我要写的是一个，带有头节点的万能双向循环链表。</p>
<hr>
<h2 id="链表的结构体"><a href="#链表的结构体" class="headerlink" title="链表的结构体"></a>链表的结构体</h2><p>首先在头文件中创建Node结构体，有三个成员变量，前继、后继和保存的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node Node;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    Node *pre;</span><br><span class="line">    Node *next;</span><br><span class="line">    void *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了后续方便使用，我们再为Node*创建一个别名为LinkList。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef Node *LinkList;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="链表的基本函数"><a href="#链表的基本函数" class="headerlink" title="链表的基本函数"></a>链表的基本函数</h2><p>链表的结构就建立好了，接下来就是实现链表的主要功能创建、插入、删除和查找了。</p>
<h3 id="实用的函数"><a href="#实用的函数" class="headerlink" title="实用的函数"></a>实用的函数</h3><p>本来应该是这样，我一开始也确实是这样做的，但是在后面写了很多重复的代码之后，才发现有一些重要的会在其他函数中用到的东西应该写在前面，之后在推倒重写了几次之后，才最终得到了令我满意的链表，所以我们先从实用的功能开始写起。</p>
<h4 id="链表头"><a href="#链表头" class="headerlink" title="链表头"></a>链表头</h4><p>前面也说过，头节点不用于保存数据，但是我看着头节点的data一直空着，觉得不顺眼，于是就想着让它保存一些其他的东西，最开始想到的就是链表的长度，但是后来又想到，链表的属性可能不止长度呢，只是我现在没想到，如果直接将data用作长度，万一以后我想加入其他的数据该怎么办？于是为了可扩展性，我们再为头节点创建个链表头结构，用于保存长度，和以后可能需要保存的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LinkListHeader LinkListHeader;</span><br><span class="line">struct LinkListHeader</span><br><span class="line">&#123;</span><br><span class="line">    size_t length;</span><br><span class="line">    void *info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我为了省事，几乎所有的长度都用size_t代替了，所以记得加上#include&lt;stddef.h&gt;<br>以后有空再去写个头文件把什么uint之类的都define了，以后就又省事一点了。</p>
</blockquote>
<p>因为不是每一个链表都会带有额外的信息，所以为了保持创建函数的简便，我们再单独创建两个函数来获取和设置链表头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void LinkListSetHeaderInfo(LinkList l, void *info, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    LinkListHeader *h = (LinkListHeader *)l-&gt;data;</span><br><span class="line">    h-&gt;info = malloc(size);</span><br><span class="line">    memcpy(h-&gt;info, info, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *LinkListGetHeaderInfo(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    return ((LinkListHeader *)l-&gt;data)-&gt;info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="获取长度和判空"><a href="#获取长度和判空" class="headerlink" title="获取长度和判空"></a>获取长度和判空</h4><p>获取长度和判空都是后面常用的函数，所以现在先实现了以后使用也方便。现在已经有了链表头，链表头保存有长度，所以我们可以很轻易的获取链表的长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t LinkListGetLength(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    return ((LinkListHeader *)l-&gt;data)-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然有了长度，那判空也容易:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int LinkListIsEmpty(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    return LinkListGetLength(l) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="根据索引获取节点"><a href="#根据索引获取节点" class="headerlink" title="根据索引获取节点"></a>根据索引获取节点</h4><p>这个是重点，我就因为这个推倒重写了两次，后面的增删改查都会使用到这个，先声明原型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node *LinkListGetNode(LinkList l, size_t index);</span><br></pre></td></tr></table></figure>
<p>首先需要制定个标准，例如我的这个链表是从1开始计数，既1就是第一个节点，n就是第n个节点。那么接下来还有两个问题：</p>
<ol>
<li>当index &#x3D; 0时应该返回什么？（size_t是无符号的，所以不考虑负数）</li>
<li>当index大于链表的长度时应该返回什么？</li>
</ol>
<p>首先，这个函数是用于获取数据节点，这个函数不管在什么情况下，都不应返回头节点。试想如果在删除的时候，如果给出了个特殊值，返回了头节点，然后将头节点删除了，后果是非常严重的。而且头节点就是我们的LinkList的变量，不需要通过其他函数获取。</p>
<p>当index&#x3D;0时，一般来想应该是返回头节点，但是前面说过了如果在删除函数中出现了头节点会很危险。考虑了删除函数，那还要考虑插入函数。假设一个链表含有n个数据，那就有n+1个插入点，所以为了满足插入的需求，我们除了需要返回n个数据节点还需要返回一种特殊值，除了头节点以外，那当然就是NULL了。所以在思考这个的时候我们对于插入的实现也有个基本的想法了，对于NULL做特殊处理也就是在头节点的后面插入，即第一个数据节点之前插入，对于其他数据节点则是在后面插入。</p>
<p>第二个问题，当index大于链表长度时应该返回什么。这个就看个人的想法了，我能想到的就是两种情况，一、返回NULL，二、返回尾节点。正常做法应该是返回NULL，但是上面也提到了，插入函数会对NULL进行特殊处理，也就是说如果在插入时指定了一个很大的数，那它有可能会插入到链表的第一位，这样看起来就非常反直觉，如果返回尾节点，那在删除和通过索引查找的时候也会出现反直觉的情况。所以这个怎么实现就看个人了，下面给出的只是我的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (LinkListIsEmpty(l) || index == 0)</span><br><span class="line">&#123;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">if (index &gt; LinkListGetLength(l))</span><br><span class="line">&#123;</span><br><span class="line">    return l-&gt;pre;// 看需求也可NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在考虑了特殊情况处理之后，就开始写查找的代码了。因为这是一个双向循环链表，所以当然要好好利用它反向查找的特性，如果index大于长度的一半时，我们可以反向查找，这样在最坏的情况下也只用遍历一半的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node *p = l;</span><br><span class="line">if (index &gt; LinkListGetLength(l) / 2)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i = LinkListGetLength(l); i &gt;= index; i—)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i = 0; i &lt; index; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码整合一下就得到了最终的函数了，这里就不重新贴出来了。</p>
<hr>
<h3 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h3><p>首先，我们的链表带有头节点，那么创建的过程就是建立一个头节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void LinkListCreate(LinkList *l)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList a = (LinkList)malloc(sizeof(Node));</span><br><span class="line">    a-&gt;pre = a;</span><br><span class="line">    a-&gt;next = a;</span><br><span class="line">    a-&gt;data = malloc(sizeof(LinkListHeader));</span><br><span class="line">    memset(a-&gt;data, 0, sizeof(LinkListHeader));</span><br><span class="line">    *l = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们要创建的是双向循环链表，所以在初始化头节点时要将前继和后继都指向头节点，这个对于后面的插入操作很重要。以及不要忘记了初始化我们的链表头。</p>
<hr>
<h3 id="链表的插入"><a href="#链表的插入" class="headerlink" title="链表的插入"></a>链表的插入</h3><p>简单说一下链表的插入，假设要在p、q两个节点中插入一个节点a，只需要让a的前继指向p，后继指向q，p的后继指向a，q的前继指向a，节点a就插入到p、q中间了，然后再将链表长度加1就完成了。</p>
<p>依然从简单的开始，双向循环链表可以很容易的实现前插和后插。前插就是在头节点和第一个数据节点之间插入新节点，尾插就是在头节点和尾节点之间插入新节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void LinkListInsertFront(LinkList l, void *data, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    Node *a = (Node *)malloc(sizeof(Node));</span><br><span class="line">    a-&gt;pre = l;</span><br><span class="line">    a-&gt;next = l-&gt;next;</span><br><span class="line">    l-&gt;next-&gt;pre = a;</span><br><span class="line">    l-&gt;next = a;</span><br><span class="line">    a-&gt;data = malloc(size);</span><br><span class="line">    memcpy(a-&gt;data, data, size);</span><br><span class="line">    ((LinkListHeader *)l-&gt;data)-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkListInsertTail(LinkList l, void *data, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    Node *a = (Node *)malloc(sizeof(Node));</span><br><span class="line">    a-&gt;pre = l-&gt;pre;</span><br><span class="line">    a-&gt;next = l;</span><br><span class="line">    l-&gt;pre-&gt;next = a;</span><br><span class="line">    l-&gt;pre = a;</span><br><span class="line">    a-&gt;data = malloc(size);</span><br><span class="line">    memcpy(a-&gt;data, data, size);</span><br><span class="line">    ((LinkListHeader *)l-&gt;data)-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就能体会到创建的时候，将头节点的前继后继都设为自身的巧妙之处了，这样在链表为空时也能够正常插入，不需要做特殊处理。</p>
<p>然后再实现指定位置插入，这里就要用到前面实现的，通过索引获取节点的函数了，然后在获取插入的节点后面插入新节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void LinkListInsert(LinkList l, size_t index, void *data, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p = LinkListGetNode(l, index);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        p = l;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *a = (Node *)malloc(sizeof(Node));</span><br><span class="line">    a-&gt;pre = p-&gt;pre;</span><br><span class="line">    a-&gt;next = p;</span><br><span class="line">    p-&gt;pre-&gt;next = a;</span><br><span class="line">    p-&gt;pre = a;</span><br><span class="line">    a-&gt;data = malloc(size);</span><br><span class="line">    memcpy(a-&gt;data, data, size);</span><br><span class="line">    ((LinkListHeader *)l-&gt;data)-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a>链表的删除</h3><blockquote>
<p>链表的删除让我想起某个漫画，一个女主因为过度使用结怨的能力，然后失去了所有的缘，这里说的缘是和他人的联系，她失去了所有的缘，就是失去了和所有人的联系。实际表现就是，人们不记得有这个人存在，虽然她还活着，但是她无法被任何人察觉。或许，这就是传说中的内存泄漏吧。</p>
</blockquote>
<p>链表的删除比插入要简单一点，只要它的前继和后继越过它直接连在一起，它就已经从链表中被删除了，因为它没有被任何一个节点指向。注意，在它彻底被删除之前要先把它释放，不然很有可能就是内存泄漏了（至于为什么只是可能不是肯定，万一在其他地方留有指向它的指针，那还是可以手动释放，但是为了防止忘记释放，应该在删除时就将节点释放）。</p>
<p>这里的删除有两种，删除数据的和不删除数据的。不删除数据是因为之后可以用这个链表实现栈和队列，出栈和出队是弹出数据，而不是把数据一起释放了，所以我们可以把从链表中移除节点和删除数据分开，从链表中移除节点只会释放节点，返回被移除节点的数据。</p>
<p>一样的先从前删和尾删开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void *LinkListRemoveFront(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    if (LinkListIsEmpty(l))</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    void *data = l-&gt;next-&gt;data;</span><br><span class="line">    Node *p = l-&gt;next-&gt;next;</span><br><span class="line">    free(l-&gt;next);</span><br><span class="line">    l-&gt;next = p;</span><br><span class="line">    p-&gt;pre = l;</span><br><span class="line">    free(p);</span><br><span class="line">    ((LinkListHeader *)l-&gt;data)-&gt;length--;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *LinkListRemoveTail(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    if (LinkListIsEmpty(l))</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    void *data = l-&gt;pre-&gt;data;</span><br><span class="line">    Node *p = l-&gt;pre-&gt;pre;</span><br><span class="line">    free(l-&gt;pre);</span><br><span class="line">    l-&gt;pre = p;</span><br><span class="line">    p-&gt;next = l;</span><br><span class="line">    ((LinkListHeader *)l-&gt;data)-&gt;length--;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除指定索引的节点只需要把删除的节点换成通过索引获取的节点p，然后判空改判断p是不是NULL就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *LinkListRemove(LinkList l, size_t index)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p = LinkListGetNode(l, index);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    void *data = p-&gt;data;</span><br><span class="line">    p-&gt;next-&gt;pre = p-&gt;pre;</span><br><span class="line">    p-&gt;pre-&gt;next = p-&gt;next;</span><br><span class="line">    free(p);</span><br><span class="line">    ((LinkListHeader *)l-&gt;data)-&gt;length--;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了移除节点之后，删除数据的移除节点就非常简单了，直接在上面3个函数外面套上free就好了，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void LinkListErase(LinkList l, size_t index)</span><br><span class="line">&#123;</span><br><span class="line">    free(LinkListRemove(l, index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkListEraseFront(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    free(LinkListRemoveFront(l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkListEraseTail(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    free(LinkListRemoveTail(l));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我还特地试了一下，C语言free(NULL)不会报错，所以这里就偷懒不判断返回值是不是NULL了。</p>
<hr>
<h3 id="链表的查找"><a href="#链表的查找" class="headerlink" title="链表的查找"></a>链表的查找</h3><p>首先是通过索引获取节点的数据，经过上面的查找和删除，现在写这个应该很简单了，就不过多赘述，直接贴代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void *LinkListGetData(LinkList l, size_t index)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p = LinkListGetNode(l, index);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *LinkListGetDataFront(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    if (LinkListIsEmpty(l))</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return l-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *LinkListGetDataTail(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    if (LinkListIsEmpty(l))</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return l-&gt;pre-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="链表的修改"><a href="#链表的修改" class="headerlink" title="链表的修改"></a>链表的修改</h3><p>这个也简单，同样是在链表的查找外面套东西，值得注意的就是赋值用memcpy，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void LinkListSetData(LinkList l, size_t index, void *data, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    void *p = LinkListGetData(l, index);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(p, data, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkListSetDataFront(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    void *p = LinkListGetDataFront(l);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(p, data, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkListSetDataTail(LinkList l)</span><br><span class="line">&#123;</span><br><span class="line">    void *p = LinkListGetDataTail(l);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(p, data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>至此链表结构和功能已经基本完成了，能够完成增删查改，应该已经符合一个链表的定义了。但是要想实际使用还是有一些问题，鉴于文章篇幅，这些就放在下一篇文章来实现了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="clfjswool0003qryq5vn63lq4" data-title="记录一个链表的实现" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/03/19/iPad%E4%B8%8A%E7%9A%84iVim%E5%AE%89%E8%A3%85%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">iPad上的iVim安装及自动补全配置</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iPad/">iPad</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">C语言</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">记录一个链表的实现</a>
          </li>
        
          <li>
            <a href="/2023/03/19/iPad%E4%B8%8A%E7%9A%84iVim%E5%AE%89%E8%A3%85%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE/">iPad上的iVim安装及自动补全配置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>